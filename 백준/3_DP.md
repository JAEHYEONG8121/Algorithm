# Algorithm

## 1. DP - 1로 만들기 - 08.09

문제 : https://www.acmicpc.net/problem/1463

**내 풀이**
```python
x = int(input()) # 수 입력받기
d = [0] * (x+1) # 1-based

for i in range(2, x+1): # 2부터 x까지 반복
    d[i] = d[i-1] + 1 # 1을 빼는 연산 -> 1회 진행
    if i % 2 == 0: # 2로 나누어 떨어질 때, 2로 나누는 연산
        d[i] = min(d[i], d[i//2]+1)
    if i % 3 ==0: # 3으로 나누어 떨어질 때, 3으로 나누는 연산
        d[i] = min(d[i], d[i//3]+1)

print(d[x])
```

- 어떤 숫자 n이 주어졌을 때 2 or 3으로 나누어 떨어지면 나누고, 1을 빼주는 3가지 종류의 연산을 통해서 1로 만드려고 할 때, 연산 횟수의 최솟값을 구하는 문제이다.
- 직관적으로 n이 2와 3의 배수라면 무조건 나누어가면서 연산하는 것이 '그리디'적인 관점에서는 연산횟수가 최소가 될 것임을 예상할 수 있다.
- But, n = 10인 경우 10 - 9 - 3 - 1과 같이 처음부터 1을 빼고 3으로 나누는 방법이 최솟값이다.
    - 동적 계획법으로 최솟값을 구하는 것이 그리디 알고리즘을 통해서 최솟값을 구하는 것과 어떤 차이가 있을까?
    - 그리디 알고리즘은 최솟값을 구하는 하나의 로직이 반례 없이 모두에 적용이 되는 경우라고 할 수 있다.
    - 동적 계획법은 모든 가능성을 염두하고 그 안에서 최솟값을 찾는 과정이라 그리디와 브루트포스의 중간의 느낌인 것 같다.

 
-  내 풀이는 <span style="color:yellow">BottomUp</span>방식이다.
- 수를 입력받고, d라는 리스트를 0이 (x+1) 칸 있는 리스트로 초기화해준다.
    - d리스트는 인덱스의 숫자가 1이 되는데 필요한 연산의 최솟값을 의미한다.
    - ex) d[2] : 2가 1이 되는데 필요한 최소 연산 횟수 : 1
- 이제 for문을 2부터 x까지 반복해주는데 3가지 연산을 동시에 고려해준다.
    - 1. d[i] = d[i-1] + 1 : d[i]는 i가 1이 되는데 필요한 최소 연산 수이다. i에서 1을 빼면 i-1이므로, d[i-1] + 1을 통해서 d[i]를 표현해준다.
    - 2. i가 2로 나누어 떨어질 때 -> d[i//2] + 1 : i를 2로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수의 표현
    - 3. i가 3으로 나누어 떨어질 때 -> d[i//3] + 1 : i를 3으로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수의 표현
- 위의 2번과 3번의 경우에는 d[i]와 최솟값을 비교하여 둘 중 더 작은 값을 저장해주면 for문이 끝날 때 d[x]에 x가 1이 되는 연산의 최솟값이 저장된다.


**Review**
- 확실히 DP는 아직도 어색하다.. 처음에 그리디처럼 생각해서 풀고 나서야 10의 경우에 예외가 발생함을 깨달았고, BottomUp방식으로 DP로 겨우 풀어낸 문제다.
- DP도 경험을 최대한 많이!!!

***

## 2. DP - RGB거리 - 08.14

문제 : https://www.acmicpc.net/problem/1149

**내 풀이**
```python
import sys
input = sys.stdin.readline

n = int(input())
RGB = []
for _ in range(n) :
    RGB.append(list(map(int, input().split())))

for i in range(1, n) :
    RGB[i][0] = min(RGB[i - 1][1], RGB[i - 1][2]) + RGB[i][0]
    RGB[i][1] = min(RGB[i - 1][0], RGB[i - 1][2]) + RGB[i][1]
    RGB[i][2] = min(RGB[i - 1][0], RGB[i - 1][1]) + RGB[i][2]
    
print(min(RGB[n - 1]))
```

- 정해진 규칙에 따라 RGB색상을 최소 비용으로 칠할 때의 비용을 출력해야하는 문제이다.
- 처음에는 2차원 리스트를 사용하지 않고, 1차원 리스트에 3개의 숫자를 받고 그 중 최솟값을 비용에 더해주는 방식으로 해보았다.
- 규칙을 지키며 최소 비용을 구하려면 다음에 들어오는 3개의 숫자 중 그 전 리스트에서의 최솟값을 갖는 값의 인덱스가 아닌 나머지 둘 중에서 최솟값을 구해서 비용에 더해주면 된다.
- 하지만, 별로 효율적이지 못하다. for문을 반복하면서 계속 새로운 리스트를 생성하고, 이전의 인덱스까지 기억해야하기 때문이다.

- 그렇기에 풀이법을 바꾸었다. 들어오는 입력을 모두 2차원 배열에 저장해보았다.
- 그렇게 저장한 다음에, for문 내에서 하나의 로직을 갖고 R, G, B값 각각을 선택할 때 얻을 수 있는 최소비용을 저장하는 일종의 브루트포스 방식으로 바꾸었다.
    - 하나의 로직이란, 1번째 집은 패스하고 2번째 집을 칠할 때 만약 R을 선택했다면 그 R을 선택했을 때의 비용은 1번째 집을 칠할 때 R을 제외한 G, B값 중 최소값과 현재 R을 선택하여 칠할 때 드는 비용을 합친 값으로 갱신해주는 것이다.
    - 이를 2차원 리스트로 구현하면 쉽다. 인덱스로 접근하기 편하기 때문이다.
- 위처럼 for문을 1부터 시작해서 n-1까지 반복하면 RGB 2차원 리스트에 담긴 값의 의미는?
    - RGB[n-1][0] : 빨강을 선택했을 때 최소 비용
    - RGB[n-1][1] : 녹색을 선택했을 때 최소 비용
    - RGB[n-1][2] : 파랑을 선택했을 때 최소 비용
- 그러므로, min(RGB[n-1])의 의미가 모든 경우에 대한 최소 비용값이 되는 것이다!


**Review**
- DP는 확실히.. 2차원 리스트,, 점화식,, 규칙 찾기 등등 느낌이 좀 오긴하지만 그리디랑 뭔가 헷갈리기도하고 참 쉽지 않다ㅠ

***

## 3. DP - 평범한 배낭 - 08.14

문제 : https://www.acmicpc.net/problem/12865

**내 풀이**
```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())

l = [[0,0]] # 물건의 무게와 가치를 담을 리스트
d = [[0]*(k+1) for _ in range(n+1)] # d[n][k] : n번째 물건 까지, 무게가 k인 배낭의 최대 가치    

for i in range(n):
    l.append(list(map(int, input().split())))

for i in range(1, n+1):
    for j in range(1, k+1):
        w = l[i][0]
        v = l[i][1]

        if j < w:
            d[i][j] = d[i-1][j]
        else:
            d[i][j] = max(d[i-1][j], d[i-1][j-w]+v)

print(d[n][k])
```

- 이 문제는 알고리즘 수업 때 배웠던 Knapsack문제이다!
- 배낭의 용량이 정해져있을 때, 최대한의 가치를 갖도록 배낭을 싸야한다. 우선 가치가 높은 물건을 최대한 배낭의 용량을 넘지 않을 만큼 담는 것이 좋을 것 같다.
- 하지만, 계속해서 어떤 것을 담는것이 더 가치있는지 판별하기가 쉽지는 않다. 2차원 리스트를 생성해서 배낭에 물건을 담을 로직을 세워보자. d[n][k] : 2차원 배열은 n번째 물건까지 살펴보았을 때, 무게가 k인 배낭의 최대 가치를 의미한다.<br/>

- 물건을 배낭에 담을 때 지켜야 할 조건은<br/>
      - 1. 현재 배낭의 허용 무게보다 넣을 물건의 무게가 더 크다면 넣지 않는다.<br/>
      - 2. 배낭의 허용 무게를 넘지 않는다면,<br/>
              - 2-1. 현재 넣을 물건의 무게만큼 배낭에서 뺀다. 그리고 현재 물건을 넣는다.<br/>
              - 2-2. 현재 물건을 넣지 않고 이전 배낭 상태로 그대로 가지고 간다.

- 위의 로직을 식으로 나타내면 다음과 같다. 현재 담을 물건의 인덱스를 i, 현재 가방 허용 용량이 j, 현재 담을 물건의 가치를 w, 가치를 v라고 할 때, <br/>
      - 1. j < w 일때, d[i][j] = d[i - 1][j] <br/>
      - 2. d[i][j] = max(d[i - 1][j - w] + v, d[i - 1][j])

**Review**
- 수업 때 배웠던 내용이라서 2차원 리스트를 생성하고 배낭에 물건을 담을 때의 로직 2가지 식을 쉽게 세울 수 있었다. 2가지 수식이 어떻게 세워지는지만 알고있다면 충분히 이해할 수 있다.

***

## 4. DP - 동전 1 - 08.16

문제 : https://www.acmicpc.net/problem/2293

**내 풀이**
```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
coin = [int(input()) for i in range(n)]
dp = [0 for _ in range(k+1)]
dp[0] = 1

for c in coin:
    for i in range(k+1):
        if i - c >= 0:
            dp[i] += dp[i-c]

print(dp[k])
```

- n개의 동전으로 k원을 만드는 경우의 수를 구해야하는 문제이다.
- DP의 핵심은 전체 문제를 '부분 문제'로 잘 나누었는가? + 부분 문제의 점화식은 무엇인가?
- 부분 문제들을 해결하며 얻는 결과값을 저장하는가?
- 위의 3가지를 고려한다면 위의 문제는 '가치의 합이 k원이 되는 경우의 수'를 구하는 문제에서 '가치의 합이 i원(1 <= i <= k)이 되는 경우의 수'로 나누어서 풀 수 있다.

- 1원을 가지고 1 ~ 10원까지 만드는 경우의 수는 모두 1이다.
- 다음으로 1원과 2원을 가지고 1 ~ 10원까지 만드는 경우의 수를 생각해보자.
    - 1원은 오직 1원으로만 만들 수 있으므로 경우의 수는 그대로 1이다.
    - 2원을 만들기 위해서는 기존에 1원으로만 만들었던 (1원, 1원)에 새로 추가된 동전 2원을 사용하는 경우가 추가되므로 경우의 수는 2가 된다.
    - 3원을 만드는 경우의 수는 (1원, 1원, 1원), (1원, 2원)인데, 1원으로 3원을 만드는 경우의 수는 처음에 이미 업데이트 되어있다. 즉, 2원이 추가되며 새로 만들어진 경우의 수는 (1원, 2원) 조합으로 2원이 추가됨으로써 만들어질 수 있는 경우의 수만 새로 더해준 것이다!

- 이를 점화식으로 표현해보자면 dp[i] += dp[i - c] 가 된다!


**Review**
- 이 문제도 결국 n개의 동전으로 k원을 만드는 경우의 수를 부분적으로 나누어서 값을 저장해가며 구한 셈이다. DP는 결국 점화식을 세우는 것과 큰 문제를 작은 부분으로 나누어서 값을 계속 저장해가며 풀어나가는 것이 핵심이라고 생각한다.

***

## 5. DP - 정수 삼각형 - 08.21

문제 : https://www.acmicpc.net/problem/1932

**내 풀이**
```python
import sys
input = sys.stdin.readline

dp = []
n = int(input())

for _ in range(n) :
    dp.append(list(map(int, input().split())))

for i in range(1, n) :
    for j in range(len(dp[i])) :
        if j == 0 :
            dp[i][j] = dp[i][j] + dp[i-1][j]
        elif j == len(dp[i]) -1 :
            dp[i][j] = dp[i][j] + dp[i-1][j-1]
        else :
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + dp[i][j]

print(max(dp[n-1]))
```

- 위에서부터 내려오면서 결국 합이 최대가 되는 경우를 찾아야하는 문제다.
- 역시나 그리디처럼 생각을 시작했다. 한 칸씩 내려가면서 고를 수 있는 2가지 중 더 큰값을 계속골라가면 되지 않을까하는 어리석은 생각을 했다.
- 하지만 그렇게하면 최대가 되지않는 경우가 무조건 발생할 수 있다는 것을 직감했다.
- 그래서 한 칸씩 내려가면서 더한 값들을 리스트에 저장해가야 겠다는 생각을 했다.

```
ex)
d[  [7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]   ]

7
3  8
8  1  0
2  7  4  4
4  5  2  6  5

i = 1 

j = 0 : d[1][0] = 3 + 7 = d[1][0] + d[0][0] = d[i][j] + d[i-1][j]
j = 1 : d[1][1] = 8 + 7 = d[1][1] + d[0][0] = d[i][j] + d[i-1][j-1]

i = 2

j = 0 : d[2][0] = 8 + 10 = d[2][0] + d[1][0] = d[i][j] + d[i-1][j]
j = 1 : d[2][1] = max(1 + 10, 1 + 15) = max(d[1][0], d[1][1]) + d[2][1] = max(d[i-1][j-1], d[i-1][j]) + d[i][j]
j = 2 : d[2][2] = 0 + 15 = d[2][2] + d[1][1] = d[i][j] + d[i-1][j-1]

```
- 위는 테스트케이스이다.
- 맨 위의 d리스트처럼 입력을 저장하고, 이중for문을 통해서 i,j로 값에 접근하고자 했다.
- i = 1부터 시작하면 3, 8각각에 7을 더해주면 된다
- i = 2일 때는, 위에서 7을 더해줘 나온 결과인 10, 15에다가 밑에 있는 8, 1, 0을 더해야한다.
- 이때 8과 0은 10, 15에다가 그냥 더해주고, 1은 10, 15모두에다가 더할 수 있으므로 2가지 중 최대값으로 갱신하고자 했다.
- 위의 과정을 인덱스로 표현하여 점화식을 세우면 가장 오른쪽 끝에 나오는 식과 같이 나온다.

**Review**
- 그렇게 어려운 문제는 아니였다. 하지만, 점점 더해가는 값을 어떻게하면 잘 저장할지 그것이 문제였다. DP는 항상 이전 값을 저장하고, 특정 점화식을 통해서 과정을 진행해나간다는 것을 항상 염두를 두고 풀어야겠다.

***

## 6. DP - 연속합 - 08.21

문제 : https://www.acmicpc.net/problem/1912

**내 풀이**
```python
import sys
input = sys.stdin.readline

n = int(input())
dp = list( map(int, input().split(' ')))
 
for i in range(1, n):
    dp[i] = max(dp[i], dp[i] + dp[i-1])
    
print(max(dp))
```

- n개의 정수로 이루어진 임의의 수열이 주어진다. 수의 범위는 -1000과 1000사이의 수이다.
- 그렇게 구성된 수열에서 '연속된' 몇 개의 수를 선택해서 구할 수 있는 합의 최댓값을 구해야한다.
- 처음에 생각한 방법은 '음수'를 기준으로 생각해보았다.
    - 최댓값이 되려면 연속된 수들의 조합이 양수가 많아야 된다고 생각했다.
    - 또한, 음수를 찾아서 음수와 음수 사이에 있는 양수들을 더하는등... 이런생각들을 해보았다.
    - 하지만, 고려해야할 상황이 너무 많다!

- 다시 한 번 더 DP에 대해 생각해보자.
- DP는 Memorization(기억법)이 중요하다.
- 이전 까지의 데이터들을 기억하면서 갱신해나가는 것이 핵심이다.

- 그렇다면, 어떻게 해결해야할까?
- 결국 연속적인 수의 합들 중에서 최댓값을 찾으면 되는 것이다.
- 수열을 리스트 안에 넣고 리스트를 순회하면서 연속된 수의 합에서 최댓값을 계속 갱신해나가면 될 것이다.

```
ex) 10
10 -4 3 1 5 6 -35 12 21 -1
for문을 1부터 시작해보자
(10 - 4 = 6)과 -4를 비교하면 6이 크다
즉, max(-4, -4 + 10 = 6) = dp[1] = 6이렇게 계속 갱신해나가는 것이다.

10 6 3 1 5 6 -35 12 21 -1
그 다음은 max(6, 6 + 3 = 9) = dp[2] = 9

10 6 9 1 5 6 -35 12 21 -1
이렇게 계속 연속된 수의 합을 구하면서 최댓값을 갱신해주는 것이다.

6까지 진행하면

10 6 9 10 15 21 -35 12 21 -1 이렇게 될텐데,
그 다음을 보자
max(-35, 21 - 35 = -14) = -14가 되고

10 6 9 10 15 21 -14 12 21 -1
다음은
max(12, 12 - 14 = -2) = 12가 된다

이게 무슨 의미인가? -> 그 전까지의 연속된 수들의 합이 모든 의미가 없이 사라지고 12가 크기 때문에 12로 갱신된다는 것이다!

이와 같은 동작을 계속해서 진행하면 결국 dp리스트에는 연속된 수의 합의 경우들로 채워지고 그 중 max()를 통해 최댓값을 뽑아주면 수열에서 연속된 수의 합 중 최댓값을 뽑아낼 수 있는 것이다!
```

**Review**
- DP문제의 아주 정석적인 유형이라고 생각한다.
- 처음에는 음수의 기준으로 생각하다보니 나눠야 할 케이스가 너무 많아졌지만 처음에는 빠르게 방향을 틀지 못했다. DP의 핵심은 점화식을 찾는 것, Memorization 이렇게 크게 2가지 부분을 지속적으로 의식적으로 생각해야겠다.

***





