# Algorithm

## 1. DP - 1로 만들기

문제 : https://www.acmicpc.net/problem/1463

**내 풀이**
```python
x = int(input()) # 수 입력받기
d = [0] * (x+1) # 1-based

for i in range(2, x+1): # 2부터 x까지 반복
    d[i] = d[i-1] + 1 # 1을 빼는 연산 -> 1회 진행
    if i % 2 == 0: # 2로 나누어 떨어질 때, 2로 나누는 연산
        d[i] = min(d[i], d[i//2]+1)
    if i % 3 ==0: # 3으로 나누어 떨어질 때, 3으로 나누는 연산
        d[i] = min(d[i], d[i//3]+1)

print(d[x])
```

- 어떤 숫자 n이 주어졌을 때 2 or 3으로 나누어 떨어지면 나누고, 1을 빼주는 3가지 종류의 연산을 통해서 1로 만드려고 할 때, 연산 횟수의 최솟값을 구하는 문제이다.
- 직관적으로 n이 2와 3의 배수라면 무조건 나누어가면서 연산하는 것이 '그리디'적인 관점에서는 연산횟수가 최소가 될 것임을 예상할 수 있다.
- But, n = 10인 경우 10 - 9 - 3 - 1과 같이 처음부터 1을 빼고 3으로 나누는 방법이 최솟값이다.
    - 동적 계획법으로 최솟값을 구하는 것이 그리디 알고리즘을 통해서 최솟값을 구하는 것과 어떤 차이가 있을까?
    - 그리디 알고리즘은 최솟값을 구하는 하나의 로직이 반례 없이 모두에 적용이 되는 경우라고 할 수 있다.
    - 동적 계획법은 모든 가능성을 염두하고 그 안에서 최솟값을 찾는 과정이라 그리디와 브루트포스의 중간의 느낌인 것 같다.
 
- 내 풀이는 <span style='background-color: #fff5b1'>BottomUp</span>방식이다.
- 수를 입력받고, d라는 리스트를 0이 (x+1) 칸 있는 리스트로 초기화해준다.
    - d리스트는 인덱스의 숫자가 1이 되는데 필요한 연산의 최솟값을 의미한다.
    - ex) d[2] : 2가 1이 되는데 필요한 최소 연산 횟수 : 1
- 이제 for문을 2부터 x까지 반복해주는데 3가지 연산을 동시에 고려해준다.
    - 1. d[i] = d[i-1] + 1 : d[i]는 i가 1이 되는데 필요한 최소 연산 수이다. i에서 1을 빼면 i-1이므로, d[i-1] + 1을 통해서 d[i]를 표현해준다.
    - 2. i가 2로 나누어 떨어질 때 -> d[i//2] + 1 : i를 2로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수의 표현
    - 3. i가 3으로 나누어 떨어질 때 -> d[i//3] + 1 : i를 3으로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수의 표현
- 위의 2번과 3번의 경우에는 d[i]와 최솟값을 비교하여 둘 중 더 작은 값을 저장해주면 for문이 끝날 때 d[x]에 x가 1이 되는 연산의 최솟값이 저장된다.
