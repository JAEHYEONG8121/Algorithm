# Algorithm

## 1. DP - 1로 만들기 - 08.09

문제 : https://www.acmicpc.net/problem/1463

**내 풀이**
```python
x = int(input()) # 수 입력받기
d = [0] * (x+1) # 1-based

for i in range(2, x+1): # 2부터 x까지 반복
    d[i] = d[i-1] + 1 # 1을 빼는 연산 -> 1회 진행
    if i % 2 == 0: # 2로 나누어 떨어질 때, 2로 나누는 연산
        d[i] = min(d[i], d[i//2]+1)
    if i % 3 ==0: # 3으로 나누어 떨어질 때, 3으로 나누는 연산
        d[i] = min(d[i], d[i//3]+1)

print(d[x])
```

- 어떤 숫자 n이 주어졌을 때 2 or 3으로 나누어 떨어지면 나누고, 1을 빼주는 3가지 종류의 연산을 통해서 1로 만드려고 할 때, 연산 횟수의 최솟값을 구하는 문제이다.
- 직관적으로 n이 2와 3의 배수라면 무조건 나누어가면서 연산하는 것이 '그리디'적인 관점에서는 연산횟수가 최소가 될 것임을 예상할 수 있다.
- But, n = 10인 경우 10 - 9 - 3 - 1과 같이 처음부터 1을 빼고 3으로 나누는 방법이 최솟값이다.
    - 동적 계획법으로 최솟값을 구하는 것이 그리디 알고리즘을 통해서 최솟값을 구하는 것과 어떤 차이가 있을까?
    - 그리디 알고리즘은 최솟값을 구하는 하나의 로직이 반례 없이 모두에 적용이 되는 경우라고 할 수 있다.
    - 동적 계획법은 모든 가능성을 염두하고 그 안에서 최솟값을 찾는 과정이라 그리디와 브루트포스의 중간의 느낌인 것 같다.

 
-  내 풀이는 <span style="color:yellow">BottomUp</span>방식이다.
- 수를 입력받고, d라는 리스트를 0이 (x+1) 칸 있는 리스트로 초기화해준다.
    - d리스트는 인덱스의 숫자가 1이 되는데 필요한 연산의 최솟값을 의미한다.
    - ex) d[2] : 2가 1이 되는데 필요한 최소 연산 횟수 : 1
- 이제 for문을 2부터 x까지 반복해주는데 3가지 연산을 동시에 고려해준다.
    - 1. d[i] = d[i-1] + 1 : d[i]는 i가 1이 되는데 필요한 최소 연산 수이다. i에서 1을 빼면 i-1이므로, d[i-1] + 1을 통해서 d[i]를 표현해준다.
    - 2. i가 2로 나누어 떨어질 때 -> d[i//2] + 1 : i를 2로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수의 표현
    - 3. i가 3으로 나누어 떨어질 때 -> d[i//3] + 1 : i를 3으로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수의 표현
- 위의 2번과 3번의 경우에는 d[i]와 최솟값을 비교하여 둘 중 더 작은 값을 저장해주면 for문이 끝날 때 d[x]에 x가 1이 되는 연산의 최솟값이 저장된다.


**Review**
- 확실히 DP는 아직도 어색하다.. 처음에 그리디처럼 생각해서 풀고 나서야 10의 경우에 예외가 발생함을 깨달았고, BottomUp방식으로 DP로 겨우 풀어낸 문제다.
- DP도 경험을 최대한 많이!!!

***

## 2. DP - RGB거리 - 08.14

문제 : https://www.acmicpc.net/problem/1149

**내 풀이**
```python
import sys
input = sys.stdin.readline

n = int(input())
RGB = []
for _ in range(n) :
    RGB.append(list(map(int, input().split())))

for i in range(1, n) :
    RGB[i][0] = min(RGB[i - 1][1], RGB[i - 1][2]) + RGB[i][0]
    RGB[i][1] = min(RGB[i - 1][0], RGB[i - 1][2]) + RGB[i][1]
    RGB[i][2] = min(RGB[i - 1][0], RGB[i - 1][1]) + RGB[i][2]
    
print(min(RGB[n - 1]))
```

- 정해진 규칙에 따라 RGB색상을 최소 비용으로 칠할 때의 비용을 출력해야하는 문제이다.
- 처음에는 2차원 리스트를 사용하지 않고, 1차원 리스트에 3개의 숫자를 받고 그 중 최솟값을 비용에 더해주는 방식으로 해보았다.
- 규칙을 지키며 최소 비용을 구하려면 다음에 들어오는 3개의 숫자 중 그 전 리스트에서의 최솟값을 갖는 값의 인덱스가 아닌 나머지 둘 중에서 최솟값을 구해서 비용에 더해주면 된다.
- 하지만, 별로 효율적이지 못하다. for문을 반복하면서 계속 새로운 리스트를 생성하고, 이전의 인덱스까지 기억해야하기 때문이다.

- 그렇기에 풀이법을 바꾸었다. 들어오는 입력을 모두 2차원 배열에 저장해보았다.
- 그렇게 저장한 다음에, for문 내에서 하나의 로직을 갖고 R, G, B값 각각을 선택할 때 얻을 수 있는 최소비용을 저장하는 일종의 브루트포스 방식으로 바꾸었다.
    - 하나의 로직이란, 1번째 집은 패스하고 2번째 집을 칠할 때 만약 R을 선택했다면 그 R을 선택했을 때의 비용은 1번째 집을 칠할 때 R을 제외한 G, B값 중 최소값과 현재 R을 선택하여 칠할 때 드는 비용을 합친 값으로 갱신해주는 것이다.
    - 이를 2차원 리스트로 구현하면 쉽다. 인덱스로 접근하기 편하기 때문이다.
- 위처럼 for문을 1부터 시작해서 n-1까지 반복하면 RGB 2차원 리스트에 담긴 값의 의미는?
    - RGB[n-1][0] : 빨강을 선택했을 때 최소 비용
    - RGB[n-1][1] : 녹색을 선택했을 때 최소 비용
    - RGB[n-1][2] : 파랑을 선택했을 때 최소 비용
- 그러므로, min(RGB[n-1])의 의미가 모든 경우에 대한 최소 비용값이 되는 것이다!


**Review**
- DP는 확실히.. 2차원 리스트,, 점화식,, 규칙 찾기 등등 느낌이 좀 오긴하지만 그리디랑 뭔가 헷갈리기도하고 참 쉽지 않다ㅠ

***

## 3. DP - 평범한 배낭 - 08.14

문제 : https://www.acmicpc.net/problem/12865

**내 풀이**
```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())

l = [[0,0]] # 물건의 무게와 가치를 담을 리스트
d = [[0]*(k+1) for _ in range(n+1)] # d[n][k] : n번째 물건 까지, 무게가 k인 배낭의 최대 가치    

for i in range(n):
    l.append(list(map(int, input().split())))

for i in range(1, n+1):
    for j in range(1, k+1):
        w = l[i][0]
        v = l[i][1]

        if j < w:
            d[i][j] = d[i-1][j]
        else:
            d[i][j] = max(d[i-1][j], d[i-1][j-w]+v)

print(d[n][k])
```

- 이 문제는 알고리즘 수업 때 배웠던 Knapsack문제이다!
- 배낭의 용량이 정해져있을 때, 최대한의 가치를 갖도록 배낭을 싸야한다. 우선 가치가 높은 물건을 최대한 배낭의 용량을 넘지 않을 만큼 담는 것이 좋을 것 같다.
- 하지만, 계속해서 어떤 것을 담는것이 더 가치있는지 판별하기가 쉽지는 않다. 2차원 리스트를 생성해서 배낭에 물건을 담을 로직을 세워보자. d[n][k] : 2차원 배열은 n번째 물건까지 살펴보았을 때, 무게가 k인 배낭의 최대 가치를 의미한다.<br/>

- 물건을 배낭에 담을 때 지켜야 할 조건은<br/>
      - 1. 현재 배낭의 허용 무게보다 넣을 물건의 무게가 더 크다면 넣지 않는다.<br/>
      - 2. 배낭의 허용 무게를 넘지 않는다면,<br/>
              - 2-1. 현재 넣을 물건의 무게만큼 배낭에서 뺀다. 그리고 현재 물건을 넣는다.<br/>
              - 2-2. 현재 물건을 넣지 않고 이전 배낭 상태로 그대로 가지고 간다.

- 위의 로직을 식으로 나타내면 다음과 같다. 현재 담을 물건의 인덱스를 i, 현재 가방 허용 용량이 j, 현재 담을 물건의 가치를 w, 가치를 v라고 할 때, <br/>
      - 1. j < w 일때, d[i][j] = d[i - 1][j] <br/>
      - 2. d[i][j] = max(d[i - 1][j - w] + v, d[i - 1][j])

**Review**
- 수업 때 배웠던 내용이라서 2차원 리스트를 생성하고 배낭에 물건을 담을 때의 로직 2가지 식을 쉽게 세울 수 있었다. 2가지 수식이 어떻게 세워지는지만 알고있다면 충분히 이해할 수 있다.


